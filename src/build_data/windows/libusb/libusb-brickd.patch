diff --git a/libusb/core.c b/libusb/core.c
index 5317d26..b2b3829 100644
--- a/libusb/core.c
+++ b/libusb/core.c
@@ -2244,40 +2244,27 @@ int usbi_gettimeofday(struct timeval *tp, void *tzp)
 }
 #endif
 
+static FILE *usbi_log_file = NULL;
+
+void API_EXPORTED libusb_set_log_file(FILE *file) {
+	usbi_log_file = file;
+}
+
+static libusb_log_function usbi_log_function = NULL;
+
+void API_EXPORTED libusb_set_log_function(libusb_log_function function) {
+	usbi_log_function = function;
+}
+
 static void usbi_log_str(struct libusb_context *ctx,
 	enum libusb_log_level level, const char * str)
 {
-#if defined(USE_SYSTEM_LOGGING_FACILITY)
-#if defined(OS_WINDOWS) || defined(OS_WINCE)
-	/* Windows CE only supports the Unicode version of OutputDebugString. */
-	WCHAR wbuf[USBI_MAX_LOG_LEN];
-	MultiByteToWideChar(CP_UTF8, 0, str, -1, wbuf, sizeof(wbuf));
-	OutputDebugStringW(wbuf);
-#elif defined(__ANDROID__)
-	int priority = ANDROID_LOG_UNKNOWN;
-	switch (level) {
-	case LIBUSB_LOG_LEVEL_INFO: priority = ANDROID_LOG_INFO; break;
-	case LIBUSB_LOG_LEVEL_WARNING: priority = ANDROID_LOG_WARN; break;
-	case LIBUSB_LOG_LEVEL_ERROR: priority = ANDROID_LOG_ERROR; break;
-	case LIBUSB_LOG_LEVEL_DEBUG: priority = ANDROID_LOG_DEBUG; break;
-	}
-	__android_log_write(priority, "libusb", str);
-#elif defined(HAVE_SYSLOG_FUNC)
-	int syslog_level = LOG_INFO;
-	switch (level) {
-	case LIBUSB_LOG_LEVEL_INFO: syslog_level = LOG_INFO; break;
-	case LIBUSB_LOG_LEVEL_WARNING: syslog_level = LOG_WARNING; break;
-	case LIBUSB_LOG_LEVEL_ERROR: syslog_level = LOG_ERR; break;
-	case LIBUSB_LOG_LEVEL_DEBUG: syslog_level = LOG_DEBUG; break;
+	if (usbi_log_file == NULL) {
+		usbi_log_file = stderr;
 	}
-	syslog(syslog_level, "%s", str);
-#else /* All of gcc, Clang, XCode seem to use #warning */
-#warning System logging is not supported on this platform. Logging to stderr will be used instead.
-	fputs(str, stderr);
-#endif
-#else
-	fputs(str, stderr);
-#endif /* USE_SYSTEM_LOGGING_FACILITY */
+
+	fputs(str, usbi_log_file);
+
 	UNUSED(ctx);
 	UNUSED(level);
 }
@@ -2285,18 +2272,22 @@ static void usbi_log_str(struct libusb_context *ctx,
 void usbi_log_v(struct libusb_context *ctx, enum libusb_log_level level,
 	const char *function, const char *format, va_list args)
 {
+	int ctx_level = 0;
 	const char *prefix = "";
 	char buf[USBI_MAX_LOG_LEN];
 	struct timeval now;
 	int global_debug, header_len, text_len;
 	static int has_debug_header_been_displayed = 0;
 
+	if (usbi_log_function != NULL) {
+		usbi_log_function(level, function, format, args);
+	}
+
 #ifdef ENABLE_DEBUG_LOGGING
 	global_debug = 1;
 	UNUSED(ctx);
+	UNUSED(ctx_level);
 #else
-	int ctx_level = 0;
-
 	USBI_GET_CONTEXT(ctx);
 	if (ctx) {
 		ctx_level = ctx->debug;
diff --git a/libusb/io.c b/libusb/io.c
index 4d03b8b..b6b5fd4 100644
--- a/libusb/io.c
+++ b/libusb/io.c
@@ -2702,7 +2702,6 @@ DEFAULT_VISIBILITY
 const struct libusb_pollfd ** LIBUSB_CALL libusb_get_pollfds(
 	libusb_context *ctx)
 {
-#ifndef OS_WINDOWS
 	struct libusb_pollfd **ret = NULL;
 	struct usbi_pollfd *ipollfd;
 	size_t i = 0;
@@ -2721,11 +2720,6 @@ const struct libusb_pollfd ** LIBUSB_CALL libusb_get_pollfds(
 out:
 	usbi_mutex_unlock(&ctx->event_data_lock);
 	return (const struct libusb_pollfd **) ret;
-#else
-	usbi_err(ctx, "external polling of libusb's internal descriptors "\
-		"is not yet supported on Windows platforms");
-	return NULL;
-#endif
 }
 
 /** \ingroup libusb_poll
diff --git a/libusb/libusb-1.0.def b/libusb/libusb-1.0.def
index 7b14e0f..7eb1433 100644
--- a/libusb/libusb-1.0.def
+++ b/libusb/libusb-1.0.def
@@ -168,3 +168,17 @@ EXPORTS
   libusb_unref_device@4 = libusb_unref_device
   libusb_wait_for_event
   libusb_wait_for_event@8 = libusb_wait_for_event
+  usbi_pipe
+  usbi_pipe@4 = usbi_pipe
+  usbi_poll
+  usbi_poll@12 = usbi_poll
+  usbi_write
+  usbi_write@12 = usbi_write
+  usbi_read
+  usbi_read@12 = usbi_read
+  usbi_close
+  usbi_close@4 = usbi_close
+  libusb_set_log_file
+  libusb_set_log_file@4 = libusb_set_log_file
+  libusb_set_log_function
+  libusb_set_log_function@4 = libusb_set_log_function
diff --git a/libusb/libusb-1.0.rc b/libusb/libusb-1.0.rc
index 3dce6d5..1f83f95 100644
--- a/libusb/libusb-1.0.rc
+++ b/libusb/libusb-1.0.rc
@@ -49,7 +49,7 @@ BEGIN
 			VALUE "LegalTrademarks", "http://www.gnu.org/licenses/lgpl-2.1.html\0"
 			VALUE "OriginalFilename", "libusb-1.0.dll\0"
 			VALUE "PrivateBuild", "\0"
-			VALUE "ProductName", "libusb-1.0\0"
+			VALUE "ProductName", "libusb-1.0-d7cf58bafb9c77514db3381e115dae5129ffba2d-tf-13\0"
 			VALUE "ProductVersion", LIBUSB_VERSIONSTRING
 			VALUE "SpecialBuild", "\0"
 		END
diff --git a/libusb/libusb.h b/libusb/libusb.h
index 5b0d522..33da8b4 100644
--- a/libusb/libusb.h
+++ b/libusb/libusb.h
@@ -60,6 +60,7 @@ typedef unsigned __int32  uint32_t;
 
 #include <time.h>
 #include <limits.h>
+#include <stdio.h>
 
 /* 'interface' might be defined as a macro on Windows, so we need to
  * undefine it so as not to break the current libusb API, because
@@ -67,6 +68,7 @@ typedef unsigned __int32  uint32_t;
  * As this can be problematic if you include windows.h after libusb.h
  * in your sources, we force windows.h to be included first. */
 #if defined(_WIN32) || defined(__CYGWIN__) || defined(_WIN32_WCE)
+#include <winsock2.h> // for struct timeval
 #include <windows.h>
 #if defined(interface)
 #undef interface
@@ -1993,6 +1995,14 @@ int LIBUSB_CALL libusb_hotplug_register_callback(libusb_context *ctx,
 void LIBUSB_CALL libusb_hotplug_deregister_callback(libusb_context *ctx,
 						libusb_hotplug_callback_handle callback_handle);
 
+void LIBUSB_CALL libusb_set_log_file(FILE *file);
+
+typedef void (LIBUSB_CALL *libusb_log_function)(enum libusb_log_level level,
+                                                const char *function,
+                                                const char *format,
+                                                va_list args);
+void LIBUSB_CALL libusb_set_log_function(libusb_log_function function);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/libusb/os/poll_windows.c b/libusb/os/poll_windows.c
index 9825607..0899e73 100644
--- a/libusb/os/poll_windows.c
+++ b/libusb/os/poll_windows.c
@@ -258,7 +258,7 @@ void exit_polling(void)
  * event. To that extent, we create a single wfd and overlapped as a means
  * to access that event.
  */
-int usbi_pipe(int filedes[2])
+int API_EXPORTED usbi_pipe(int filedes[2])
 {
 	int i;
 	OVERLAPPED* overlapped;
@@ -506,7 +506,7 @@ struct winfd overlapped_to_winfd(OVERLAPPED* overlapped)
  * Currently, this function only accepts one of POLLIN or POLLOUT per fd
  * (but you can create multiple fds from the same handle for read and write)
  */
-int usbi_poll(struct pollfd *fds, unsigned int nfds, int timeout)
+int API_EXPORTED usbi_poll(struct pollfd *fds, unsigned int nfds, int timeout)
 {
 	unsigned i;
 	int _index, object_index, triggered;
@@ -628,7 +628,7 @@ poll_exit:
 /*
  * close a fake pipe fd
  */
-int usbi_close(int fd)
+int API_EXPORTED usbi_close(int fd)
 {
 	int _index;
 	int r = -1;
@@ -650,7 +650,7 @@ int usbi_close(int fd)
 /*
  * synchronous write for fake "pipe" signaling
  */
-ssize_t usbi_write(int fd, const void *buf, size_t count)
+ssize_t API_EXPORTED usbi_write(int fd, const void *buf, size_t count)
 {
 	int _index;
 	UNUSED(buf);
@@ -686,7 +686,7 @@ ssize_t usbi_write(int fd, const void *buf, size_t count)
 /*
  * synchronous read for fake "pipe" signaling
  */
-ssize_t usbi_read(int fd, void *buf, size_t count)
+ssize_t API_EXPORTED usbi_read(int fd, void *buf, size_t count)
 {
 	int _index;
 	ssize_t r = -1;
diff --git a/libusb/os/poll_windows.h b/libusb/os/poll_windows.h
index aa4c985..1feb511 100644
--- a/libusb/os/poll_windows.h
+++ b/libusb/os/poll_windows.h
@@ -55,7 +55,7 @@ enum windows_version {
 };
 extern int windows_version;
 
-#define MAX_FDS     256
+#define MAX_FDS     4096
 
 #define POLLIN      0x0001    /* There is data to read */
 #define POLLPRI     0x0002    /* There is urgent data to read */
@@ -90,11 +90,11 @@ struct winfd {
 };
 extern const struct winfd INVALID_WINFD;
 
-int usbi_pipe(int pipefd[2]);
-int usbi_poll(struct pollfd *fds, unsigned int nfds, int timeout);
-ssize_t usbi_write(int fd, const void *buf, size_t count);
-ssize_t usbi_read(int fd, void *buf, size_t count);
-int usbi_close(int fd);
+int LIBUSB_CALL usbi_pipe(int pipefd[2]);
+int LIBUSB_CALL usbi_poll(struct pollfd *fds, unsigned int nfds, int timeout);
+ssize_t LIBUSB_CALL usbi_write(int fd, const void *buf, size_t count);
+ssize_t LIBUSB_CALL usbi_read(int fd, void *buf, size_t count);
+int LIBUSB_CALL usbi_close(int fd);
 
 void init_polling(void);
 void exit_polling(void);
diff --git a/libusb/os/windows_nt_common.c b/libusb/os/windows_nt_common.c
index 93e6278..bdc6cc3 100644
--- a/libusb/os/windows_nt_common.c
+++ b/libusb/os/windows_nt_common.c
@@ -510,6 +510,10 @@ static void windows_transfer_callback(struct usbi_transfer *itransfer, uint32_t
 			status = LIBUSB_TRANSFER_CANCELLED;
 		}
 		break;
+	case ERROR_FILE_NOT_FOUND:
+		usbi_dbg("detected disconnect");
+		status = LIBUSB_TRANSFER_NO_DEVICE;
+		break;
 	default:
 		usbi_err(ITRANSFER_CTX(itransfer), "detected I/O error %u: %s", io_result, windows_error_str(io_result));
 		status = LIBUSB_TRANSFER_ERROR;
@@ -580,8 +584,8 @@ int windows_handle_events(struct libusb_context *ctx, struct pollfd *fds, POLL_N
 			windows_handle_callback(transfer, io_result, io_size);
 		} else {
 			usbi_err(ctx, "could not find a matching transfer for fd %d", fds[i]);
-			r = LIBUSB_ERROR_NOT_FOUND;
-			break;
+			//r = LIBUSB_ERROR_NOT_FOUND;
+			//break;
 		}
 	}
 	usbi_mutex_unlock(&ctx->open_devs_lock);
diff --git a/libusb/os/windows_winusb.c b/libusb/os/windows_winusb.c
index 9fe2956..e9ceb57 100644
--- a/libusb/os/windows_winusb.c
+++ b/libusb/os/windows_winusb.c
@@ -1000,6 +1000,14 @@ static int init_device(struct libusb_device *dev, struct libusb_device *parent_d
 	unsigned long tmp_id;
 	unsigned i;
 
+	if (strncmp(device_id, "\\\\.\\USB#VID_16D0&PID_09E5&MI_01", 31) == 0 && port_number > 1) {
+		// the second function (MI_01) of the RED Brick seems to be reported on
+		// the wrong port number, try to fix this
+		usbi_dbg("trying to fix port number %u for %s", port_number, device_id);
+
+		--port_number;
+	}
+
 	if ((dev == NULL) || (parent_dev == NULL))
 		return LIBUSB_ERROR_NOT_FOUND;
 
@@ -1052,6 +1060,11 @@ static int init_device(struct libusb_device *dev, struct libusb_device *parent_d
 
 	memset(&conn_info, 0, sizeof(conn_info));
 	if (priv->depth != 0) { // Not a HCD hub
+		if (port_number == 0) {
+			usbi_warn(ctx, "got invalid port number for '%s', if this device is connected to a Renesas/NEC USB controller update the driver", device_id);
+			return LIBUSB_ERROR_NO_DEVICE;
+		}
+
 		handle = CreateFileA(parent_priv->path, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
 			FILE_FLAG_OVERLAPPED, NULL);
 		if (handle == INVALID_HANDLE_VALUE) {
@@ -1131,6 +1144,15 @@ static int init_device(struct libusb_device *dev, struct libusb_device *parent_d
 	usbi_dbg("(bus: %u, addr: %u, depth: %u, port: %u): '%s'",
 		dev->bus_number, dev->device_address, priv->depth, priv->port, device_id);
 
+	if (strncmp(device_id, "\\\\.\\USB#VID_16D0&PID_09E5&MI_", 29) == 0) {
+		// don't add interfaces of the composite RED Brick devices to the
+		// device list. this will just result in the device list containing
+		// the device multiple times, which will confuse brickd
+		usbi_dbg("hiding composite device function from devices list: %s", device_id);
+
+		return LIBUSB_ERROR_NO_DEVICE;
+	}
+
 	return LIBUSB_SUCCESS;
 }
 
@@ -1277,7 +1299,7 @@ static int windows_get_device_list(struct libusb_context *ctx, struct discovered
 {
 	struct discovered_devs *discdevs;
 	HDEVINFO dev_info = { 0 };
-	const char *usb_class[] = {"USB", "NUSB3", "IUSB3"};
+	const char *usb_class[] = {"USB", "NUSB3", "IUSB3", "IARUSB3"};
 	SP_DEVINFO_DATA dev_info_data = { 0 };
 	SP_DEVICE_INTERFACE_DETAIL_DATA_A *dev_interface_details = NULL;
 	GUID hid_guid;
@@ -1331,7 +1353,7 @@ static int windows_get_device_list(struct libusb_context *ctx, struct discovered
 		return LIBUSB_ERROR_NO_MEM;
 
 	for (pass = 0; ((pass < nb_guids) && (r == LIBUSB_SUCCESS)); pass++) {
-//#define ENUM_DEBUG
+#define ENUM_DEBUG
 #if defined(ENABLE_LOGGING) && defined(ENUM_DEBUG)
 		const char *passname[] = { "HCD", "HUB", "GEN", "DEV", "HID", "EXT" };
 		usbi_dbg("#### PROCESSING %ss %s", passname[(pass <= HID_PASS) ? pass : (HID_PASS + 1)],
@@ -1370,6 +1392,7 @@ static int windows_get_device_list(struct libusb_context *ctx, struct discovered
 				// Workaround for a Nec/Renesas USB 3.0 driver bug where root hubs are
 				// being listed under the "NUSB3" PnP Symbolic Name rather than "USB".
 				// The Intel USB 3.0 driver behaves similar, but uses "IUSB3"
+				// The Intel Alpine Ridge USB 3.1 driver uses "IARUSB3"
 				for (; class_index < ARRAYSIZE(usb_class); class_index++) {
 					if (get_devinfo_data(ctx, &dev_info, &dev_info_data, usb_class[class_index], i))
 						break;
@@ -2176,7 +2199,7 @@ static int common_configure_endpoints(int sub_api, struct libusb_device_handle *
 }
 
 // These names must be uppercase
-static const char *hub_driver_names[] = {"USBHUB", "USBHUB3", "USB3HUB", "NUSB3HUB", "RUSB3HUB", "FLXHCIH", "TIHUB3", "ETRONHUB3", "VIAHUB3", "ASMTHUB3", "IUSB3HUB", "VUSB3HUB", "AMDHUB30", "VHHUB"};
+static const char *hub_driver_names[] = {"USBHUB", "USBHUB3", "USB3HUB", "NUSB3HUB", "RUSB3HUB", "FLXHCIH", "TIHUB3", "ETRONHUB3", "VIAHUB3", "ASMTHUB3", "IUSB3HUB", "VUSB3HUB", "AMDHUB30", "VHHUB", "AUSB3HUB"};
 static const char *composite_driver_names[] = {"USBCCGP"};
 static const char *winusbx_driver_names[] = WINUSBX_DRV_NAMES;
 static const char *hid_driver_names[] = {"HIDUSB", "MOUHID", "KBDHID"};
