diff --git a/libusb/core.c b/libusb/core.c
index 72faac4..ce09ef5 100644
--- a/libusb/core.c
+++ b/libusb/core.c
@@ -2031,40 +2031,21 @@ int usbi_gettimeofday(struct timeval *tp, void *tzp)
 }
 #endif
 
+static FILE *usbi_log_file = NULL;
+
+void API_EXPORTED libusb_set_log_file(FILE *file) {
+	usbi_log_file = file;
+}
+
 static void usbi_log_str(struct libusb_context *ctx,
 	enum libusb_log_level level, const char * str)
 {
-#if defined(USE_SYSTEM_LOGGING_FACILITY)
-#if defined(OS_WINDOWS) || defined(OS_WINCE)
-	/* Windows CE only supports the Unicode version of OutputDebugString. */
-	WCHAR wbuf[USBI_MAX_LOG_LEN];
-	MultiByteToWideChar(CP_UTF8, 0, str, -1, wbuf, sizeof(wbuf));
-	OutputDebugStringW(wbuf);
-#elif defined(__ANDROID__)
-	int priority = ANDROID_LOG_UNKNOWN;
-	switch (level) {
-	case LIBUSB_LOG_LEVEL_INFO: priority = ANDROID_LOG_INFO; break;
-	case LIBUSB_LOG_LEVEL_WARNING: priority = ANDROID_LOG_WARN; break;
-	case LIBUSB_LOG_LEVEL_ERROR: priority = ANDROID_LOG_ERROR; break;
-	case LIBUSB_LOG_LEVEL_DEBUG: priority = ANDROID_LOG_DEBUG; break;
-	}
-	__android_log_write(priority, "libusb", str);
-#elif defined(HAVE_SYSLOG_FUNC)
-	int syslog_level = LOG_INFO;
-	switch (level) {
-	case LIBUSB_LOG_LEVEL_INFO: syslog_level = LOG_INFO; break;
-	case LIBUSB_LOG_LEVEL_WARNING: syslog_level = LOG_WARNING; break;
-	case LIBUSB_LOG_LEVEL_ERROR: syslog_level = LOG_ERR; break;
-	case LIBUSB_LOG_LEVEL_DEBUG: syslog_level = LOG_DEBUG; break;
+	if (usbi_log_file == NULL) {
+		usbi_log_file = stderr;
 	}
-	syslog(syslog_level, "%s", str);
-#else /* All of gcc, Clang, XCode seem to use #warning */
-#warning System logging is not supported on this platform. Logging to stderr will be used instead.
-	fputs(str, stderr);
-#endif
-#else
-	fputs(str, stderr);
-#endif /* USE_SYSTEM_LOGGING_FACILITY */
+
+	fputs(str, usbi_log_file);
+
 	UNUSED(ctx);
 	UNUSED(level);
 }
@@ -2240,3 +2221,7 @@ const struct libusb_version * LIBUSB_CALL libusb_get_version(void)
 {
 	return &libusb_version_internal;
 }
+
+void API_EXPORTED libusb_free(void *ptr) {
+	free(ptr);
+}
diff --git a/libusb/io.c b/libusb/io.c
index 4f22963..6da4895 100644
--- a/libusb/io.c
+++ b/libusb/io.c
@@ -2483,7 +2483,6 @@ DEFAULT_VISIBILITY
 const struct libusb_pollfd ** LIBUSB_CALL libusb_get_pollfds(
 	libusb_context *ctx)
 {
-#ifndef OS_WINDOWS
 	struct libusb_pollfd **ret = NULL;
 	struct usbi_pollfd *ipollfd;
 	size_t i = 0;
@@ -2505,11 +2504,6 @@ const struct libusb_pollfd ** LIBUSB_CALL libusb_get_pollfds(
 out:
 	usbi_mutex_unlock(&ctx->pollfds_lock);
 	return (const struct libusb_pollfd **) ret;
-#else
-	usbi_err(ctx, "external polling of libusbx's internal descriptors "\
-		"is not yet supported on Windows platforms");
-	return NULL;
-#endif
 }
 
 /* Backends may call this from handle_events to report disconnection of a
diff --git a/libusb/libusb-1.0.def b/libusb/libusb-1.0.def
index cb0e32a..53cda36 100644
--- a/libusb/libusb-1.0.def
+++ b/libusb/libusb-1.0.def
@@ -156,3 +156,17 @@ EXPORTS
   libusb_unref_device@4 = libusb_unref_device
   libusb_wait_for_event
   libusb_wait_for_event@8 = libusb_wait_for_event
+  usbi_pipe
+  usbi_pipe@4 = usbi_pipe
+  usbi_poll
+  usbi_poll@12 = usbi_poll
+  usbi_write
+  usbi_write@12 = usbi_write
+  usbi_read
+  usbi_read@12 = usbi_read
+  usbi_close
+  usbi_close@4 = usbi_close
+  libusb_set_log_file
+  libusb_set_log_file@4 = libusb_set_log_file
+  libusb_free
+  libusb_free@4 = libusb_free
diff --git a/libusb/libusb-1.0.rc b/libusb/libusb-1.0.rc
index ae49757..c801b5b 100644
--- a/libusb/libusb-1.0.rc
+++ b/libusb/libusb-1.0.rc
@@ -49,7 +49,7 @@ BEGIN
 			VALUE "LegalTrademarks", "http://www.gnu.org/licenses/lgpl-2.1.html\0"
 			VALUE "OriginalFilename", "libusb-1.0.dll\0"
 			VALUE "PrivateBuild", "\0"
-			VALUE "ProductName", "libusb-1.0\0"
+			VALUE "ProductName", "libusb-1.0-a9cd54f24d566062a461d27f615365f41a3d11e8-tf-8\0"
 			VALUE "ProductVersion", LIBUSB_VERSIONSTRING
 			VALUE "SpecialBuild", "\0"
 		END
diff --git a/libusb/libusb.h b/libusb/libusb.h
index da3f1ef..1dd478a 100644
--- a/libusb/libusb.h
+++ b/libusb/libusb.h
@@ -60,6 +60,7 @@ typedef unsigned __int32  uint32_t;
 
 #include <time.h>
 #include <limits.h>
+#include <stdio.h>
 
 /* 'interface' might be defined as a macro on Windows, so we need to
  * undefine it so as not to break the current libusbx API, because
@@ -67,6 +68,7 @@ typedef unsigned __int32  uint32_t;
  * As this can be problematic if you include windows.h after libusb.h
  * in your sources, we force windows.h to be included first. */
 #if defined(_WIN32) || defined(__CYGWIN__) || defined(_WIN32_WCE)
+#include <winsock2.h> // for struct timeval
 #include <windows.h>
 #if defined(interface)
 #undef interface
@@ -1948,6 +1950,14 @@ int LIBUSB_CALL libusb_hotplug_register_callback(libusb_context *ctx,
 void LIBUSB_CALL libusb_hotplug_deregister_callback(libusb_context *ctx,
 						libusb_hotplug_callback_handle handle);
 
+#define LIBUSBX_EXPORTS_SET_LOG_FILE_FUNCTION 1
+
+void LIBUSB_CALL libusb_set_log_file(FILE *file);
+
+#define LIBUSBX_EXPORTS_FREE_FUNCTION 1
+
+void LIBUSB_CALL libusb_free(void *ptr);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/libusb/os/poll_windows.c b/libusb/os/poll_windows.c
index abe8761..bd86a3d 100644
--- a/libusb/os/poll_windows.c
+++ b/libusb/os/poll_windows.c
@@ -256,7 +256,7 @@ void exit_polling(void)
  * event. To that extent, we create a single wfd and overlapped as a means
  * to access that event.
  */
-int usbi_pipe(int filedes[2])
+int API_EXPORTED usbi_pipe(int filedes[2])
 {
 	int i;
 	OVERLAPPED* overlapped;
@@ -504,7 +504,7 @@ struct winfd overlapped_to_winfd(OVERLAPPED* overlapped)
  * Currently, this function only accepts one of POLLIN or POLLOUT per fd
  * (but you can create multiple fds from the same handle for read and write)
  */
-int usbi_poll(struct pollfd *fds, unsigned int nfds, int timeout)
+int API_EXPORTED usbi_poll(struct pollfd *fds, unsigned int nfds, int timeout)
 {
 	unsigned i;
 	int _index, object_index, triggered;
@@ -626,7 +626,7 @@ poll_exit:
 /*
  * close a fake pipe fd
  */
-int usbi_close(int fd)
+int API_EXPORTED usbi_close(int fd)
 {
 	int _index;
 	int r = -1;
@@ -648,7 +648,7 @@ int usbi_close(int fd)
 /*
  * synchronous write for fake "pipe" signaling
  */
-ssize_t usbi_write(int fd, const void *buf, size_t count)
+ssize_t API_EXPORTED usbi_write(int fd, const void *buf, size_t count)
 {
 	int _index;
 	UNUSED(buf);
@@ -684,7 +684,7 @@ ssize_t usbi_write(int fd, const void *buf, size_t count)
 /*
  * synchronous read for fake "pipe" signaling
  */
-ssize_t usbi_read(int fd, void *buf, size_t count)
+ssize_t API_EXPORTED usbi_read(int fd, void *buf, size_t count)
 {
 	int _index;
 	ssize_t r = -1;
diff --git a/libusb/os/poll_windows.h b/libusb/os/poll_windows.h
index deed206..294dbe8 100644
--- a/libusb/os/poll_windows.h
+++ b/libusb/os/poll_windows.h
@@ -49,7 +49,7 @@ enum windows_version {
 };
 extern enum windows_version windows_version;
 
-#define MAX_FDS     256
+#define MAX_FDS     4096
 
 #define POLLIN      0x0001    /* There is data to read */
 #define POLLPRI     0x0002    /* There is urgent data to read */
@@ -84,11 +84,11 @@ struct winfd {
 };
 extern const struct winfd INVALID_WINFD;
 
-int usbi_pipe(int pipefd[2]);
-int usbi_poll(struct pollfd *fds, unsigned int nfds, int timeout);
-ssize_t usbi_write(int fd, const void *buf, size_t count);
-ssize_t usbi_read(int fd, void *buf, size_t count);
-int usbi_close(int fd);
+int LIBUSB_CALL usbi_pipe(int pipefd[2]);
+int LIBUSB_CALL usbi_poll(struct pollfd *fds, unsigned int nfds, int timeout);
+ssize_t LIBUSB_CALL usbi_write(int fd, const void *buf, size_t count);
+ssize_t LIBUSB_CALL usbi_read(int fd, void *buf, size_t count);
+int LIBUSB_CALL usbi_close(int fd);
 
 void init_polling(void);
 void exit_polling(void);
diff --git a/libusb/os/windows_usb.c b/libusb/os/windows_usb.c
index 4493088..3c59e22 100644
--- a/libusb/os/windows_usb.c
+++ b/libusb/os/windows_usb.c
@@ -1126,6 +1126,11 @@ static int init_device(struct libusb_device* dev, struct libusb_device* parent_d
 	}
 	memset(&conn_info, 0, sizeof(conn_info));
 	if (priv->depth != 0) {	// Not a HCD hub
+		if (port_number == 0) {
+			usbi_warn(ctx, "got invalid port number for '%s', if this device is connected to a Renesas/NEC USB controller update the driver", device_id);
+			return LIBUSB_ERROR_NO_DEVICE;
+		}
+
 		handle = CreateFileA(parent_priv->path, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
 			FILE_FLAG_OVERLAPPED, NULL);
 		if (handle == INVALID_HANDLE_VALUE) {
@@ -2077,6 +2082,10 @@ static void windows_transfer_callback(struct usbi_transfer *itransfer, uint32_t
 			status = LIBUSB_TRANSFER_CANCELLED;
 		}
 		break;
+	case ERROR_FILE_NOT_FOUND:
+		usbi_dbg("detected disconnect");
+		status = LIBUSB_TRANSFER_NO_DEVICE;
+		break;
 	default:
 		usbi_err(ITRANSFER_CTX(itransfer), "detected I/O error %d: %s", io_result, windows_error_str(io_result));
 		status = LIBUSB_TRANSFER_ERROR;
@@ -2152,7 +2161,7 @@ static int windows_handle_events(struct libusb_context *ctx, struct pollfd *fds,
 			windows_handle_callback(transfer, io_result, io_size);
 		} else {
 			usbi_err(ctx, "could not find a matching transfer for fd %x", fds[i]);
-			return LIBUSB_ERROR_NOT_FOUND;
+			//return LIBUSB_ERROR_NOT_FOUND;
 		}
 	}
 
